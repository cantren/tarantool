#!/usr/bin/env tarantool
local ffi = require('ffi')
local fio = require('fio')
local fun = require('fun')
local log = require('log')
local pwd = require('pwd')
local json = require('json')
local errno = require('errno')
local argparse = require('internal.argparse').parse

local yaml  = require('yaml').new()
yaml.cfg{
    encode_invalid_numbers = true,
    encode_load_metatable = true,
    encode_use_tostring = true,
    encode_invalid_as_nil = true,
}

local tarantoolctl = nil

local function log_traceback(level, ldepth)
    local function get_traceback(ldepth, level)
        local tb = {}
        local level = 2 + (ldepth or 1)
        while true do
            local info = debug.getinfo(level)
            assert(type(info) == 'nil' or type(info) == 'table')
            if info == nil then
                break
            end
            table.insert(tb, {
                line = info.currentline or 0,
                what = info.what or 'undef',
                file = info.short_src or info.src or 'eval',
                name = info.name,
            })
            level = level + 1
        end
        return tb
    end
    level = level and log[level] or log.verbose
    for _, fr in ipairs(get_traceback(ldepth)) do
        local name = ''
        if fr.name ~= nil then
            name = (" function '%s'"):format(fr.name)
        end
        level("[%-4s]%s at <%s:%d>", fr.what, name, fr.file, fr.line)
    end
end

local function log_syserror(fmt, ...)
    if select('#', ...) > 0 then
        fmt = fmt:format(...)
    end
    log.error(('[errno %d] %s: %s'):format(errno(), fmt, errno.strerror()))
end

local function error(...)
    local fmt_pos, level = 2, 2
    local fmt = ...
    if type(fmt) == 'number' then
        fmt_pos = 3
        level, fmt = ...
    end
    -- format error message
    local stat = true
    if select('#', ...) >= fmt_pos then
        stat, fmt = pcall(string.format, select(fmt_pos - 1, ...))
    end
    _G.error(fmt, stat == false and 2 or level)
end

local function syserror(...)
    local fmt_pos, level = 2, 2
    local fmt = ...
    if type(fmt) == 'number' then
        fmt_pos = 3
        level, fmt = ...
    end
    -- format error message
    fmt = ('[errno %d] %s: %s'):format(fmt, errno.strerror())
    local stat, fmt = pcall(string.format, fmt, errno(), select(fmt_pos, ...))
    _G.error(fmt, stat == false and 2 or level)
end

--------------------------------------------------------------------------------
--                                    ctl                                     --
--------------------------------------------------------------------------------

-- '/etc/default/tarantool'
local DEFAULT_DEFAULTS_PATH =
    '@CMAKE_INSTALL_FULL_SYSCONFDIR@/@SYSCONFIG_DEFAULT@/tarantool'
local DEFAULT_WRAPPER_NAME  = 'tarantoolctl'
local ENV_PLUGIN_PATH       = 'TARANTOOLCTL_PLUGIN_PATH'

--------------------------------------------------------------------------------
--                                 Utilities                                  --
--------------------------------------------------------------------------------

local function execute_wrapped(func, ...)
    local function xpcall_traceback_callback(err)
        if err == 'usage' then
            return err
        end
        err = err or '<none>'
        if type(err) == 'cdata' then
            err = tostring(err)
        end
        local err_place = nil
        if err:match(':%d+: ') then
            err_place, err = err:match('(.+:%d+): (.+)')
        end
        log.error('Error catched: %s', err)
        if err_place ~= nil then
            log.error("Error occured at '%s'", err_place)
        end
        log.error('')
        log_traceback('error', 2)
        return err
    end

    return xpcall(func, xpcall_traceback_callback, ...)
end

local function is_callable(arg)
    if arg ~= nil then
        local mt = (type(arg) == 'table' and getmetatable(arg) or nil)
        if type(arg) == 'function' or mt ~= nil and
                                      type(mt.__call) == 'function' then
            return true
        end
    end
    return false
end

local function string_split(path, separator)
   local fields, separator = {}, separator or '.'
   path:gsub("([^" .. separator .. "]+)", function(c) table.insert(fields, c) end)
   return #fields, fields
end

local function split_config(path)
    local fields = {}
    path:gsub("([^.]+)", function(c) table.insert(fields, c) end)
    return #fields, fields
end

local function load_file_sandboxed(path, env, desc)
    path = fio.abspath(path)
    local ufunc, msg = loadfile(path)
    if not ufunc then
        log.error("Failed to load %s file '%s':", desc, path)
        log.error(msg)
        return false
    end
    debug.setfenv(ufunc, setmetatable(env, { __index = _G }))
    local rval = { execute_wrapped(ufunc) }
    if not rval[1] then
        log.error("Failed to execute %s file '%s':", desc, path)
        log.error(rval[2])
        return false
    end
    table.remove(rval, 1)
    return unpack(rval)
end

local function load_func_sandboxed(ufunc, env, desc)
    debug.setfenv(ufunc, setmetatable(env, { __index = _G }))
    local rval = { execute_wrapped(ufunc) }
    if not rval[1] then
        log.error("Failed to execute '%s' function:", desc)
        log.error(rval[2])
        return false
    end
    table.remove(rval, 1)
    return unpack(rval)
end

local function deepcopy(orig)
    local orig_type = type(orig)
    local copy = orig
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = deepcopy(orig_value)
        end
    end
    return copy
end

package.loaded['ctl.utils'] = {
    string_split    = string_split,
    execute_wrapped = execute_wrapped,
    error           = error,
    syserror        = syserror,
    log_syserror    = log_syserror,
}

--------------------------------------------------------------------------------
--                               Configuration                                --
--------------------------------------------------------------------------------

local function tarantoolctl_cfg_new()
    local cfg = {
        values = {},
        defaults = {},
        formats = setmetatable({
            lua = function(self, default_path)
                local function load_dictionary(self, name, value)
                    -- assume, that dicts have only string keys (for now)
                    name = name == nil and '' or name .. '.'
                    for subname, subvalue in pairs(value) do
                        subname = name .. subname
                        if type(subvalue) == 'table' then
                            load_dictionary(self, subname, subvalue)
                        else
                            self.values[subname] = subvalue
                        end
                    end
                end

                local result_environment = {}
                load_file_sandboxed(default_path, result_environment, 'defaults')
                load_dictionary(self, nil, result_environment)
            end
        }, {
            __index = function(self, format)
                self:error('unknown config format "%s"', format)
            end
        })
    }
    return setmetatable(cfg, {
        __index = {
            register = function(self, name, opts)
                opts = deepcopy(opts or {})
                self.defaults[name] = opts

            end,
            get = function(self, name)
                local def_value = self.defaults[name]
                if self.values[name] == nil then
                    local default = def_value.default
                    if is_callable(default) then default = default() end
                    self.values[name] = default
                end
                local value = self.values[name]
                if value == nil and def_value.deprecated ~= nil then
                    value = self.values[def_value.deprecated]
                    if value ~= nil then
                        log.error('using deprecated value "%s" (now called "%s")',
                                  def_value.deprecated, name)
                    end
                end
                local tp = def_value.type
                if value ~= nil and type(value) ~= tp then
                    log.error('config "%s": expected type "%s", got "%s"',
                              name, tp, type(value))
                    return nil
                end
                return value
            end,
            load = function(self, default_path)
                if default_path == nil then
                    return
                end
                local ext_len, ext = split_config(fio.basename(default_path))
                local format = ext_len > 1 and ext[ext_len] or 'lua'
                self.formats[format](self, default_path)
            end,
        },
    })
end

--------------------------------------------------------------------------------
--                        library/methods abstractions                        --
--------------------------------------------------------------------------------

local function usage_header()
    log.error("Tarantool client utility (%s)", _TARANTOOL)
    log.error("Usage:")
    log.error("")
end

-- split long line into muple one's with max width of 80 charachters and
-- prepends with depth spaces
local function print_aligned(lines, depth)
    local fields = {}
    if lines ~= nil then
        lines:gsub("([^\n]+)", function(val)
            local rv = val:gsub("^%s*(.-)%s*$", "%1")
            local fs = string.byte(rv, 1)
            if fs ~= 44 and fs ~= 46 and fs ~= 58 and fs ~= 59 then
                rv = ' ' .. rv
            end
            table.insert(fields, rv)
        end)
    end
    lines = table.concat(fields, '')
    fields = {}
    while true do
        if #lines == 0 then break end
        local line = nil
        if #lines <= 80 then
            line = lines
        else
            line = lines:sub(0, 80 - depth + 1):match("(.*%s)[^%s]*")
        end
        if not line or #line == 0 then
            line = lines:sub(0, 80 - depth) .. '-'
        end
        lines = lines:sub(#line + 1)
        line = line:gsub("^%s*(.-)%s*$", "%1")
        table.insert(fields, string.rep(' ', depth) .. line)
    end
    return fields
end

local tctl_method_methods = {
    run = function(self, context)
        log.verbose("calling callback '%s'", self.name)
        local stat, rv = execute_wrapped(self.callback, context)
        if rv == 'usage' then
            return self:usage()
        end
        -- out:write(string.format('exiting "%s" "%s"\n', rv, self.opts.exiting))
        if self.opts.exiting or rv == false then
            os.exit(rv and 0 or 1)
        end
        return rv
    end,
    usage = function(self, opts)
        opts = opts or {}
        opts.depth = opts.depth

        local header = self.help.header
        if tarantoolctl.linkmode then
            if not self.help.linkmode then
                return
            end
            header = self.help.linkmode
        end
        if type(header) ~= 'table' then
            header = { header }
        end
        for _, line in ipairs(header) do
            line = line:format(tarantoolctl.program_name)
            local is_first_line = false
            for _, line in ipairs(
                print_aligned(line, opts.depth)
            ) do
                if is_first_line then line = '    ' .. line end
                log.info(line)
                is_first_line = true
            end
        end

        opts.detailed = opts.detailed or tarantoolctl.help
        if opts.detailed then
            local description = self.help.description
            log.info("")
            for _, line in ipairs(
                print_aligned(description, opts.depth + 2)
            ) do
                log.info(line)
            end
            local arguments   = self.help.arguments
            log.info("")
            if arguments then
                for _, arg in ipairs(arguments) do
                    log.info('%s%s', string.rep(' ', opts.depth + 2), arg[1])
                    for _, line in ipairs(
                        print_aligned(arg[2], opts.depth + 4)
                    ) do
                        log.info(line)
                    end
                end
                log.info("")
            end
        end
        return false
    end,
    plugin_api = function(self)
        return self
    end,
    public_api = function(self)
        return self
    end
}

local function tctl_method_new(name, callback, opts)
    -- checks must be here
    local help = opts.help
    opts.help = nil
    return setmetatable({
        name     = name,
        callback = callback,
        opts     = opts,
        help     = help
    }, {
        __index = tctl_method_methods
    })
end

local tctl_library_plugin_methods = {
    register_method  = function(self, name, callback, opts)
        log.verbose("registering method '%s' for library '%s'", name, self.name)
        opts = deepcopy(opts or {})
        opts.help = opts.help or {}
        assert(type(opts.help.header) == 'string' or
               type(opts.help.header) == 'table')
        assert(type(opts.help.description) == 'string')
        if not opts.help.weight then
            opts.help.weight = fun.iter(self.methods):map(function(_, val)
                return val.help.weight
            end):chain({ 0 }):max() + 10
        end
        if self.methods[name] ~= nil then
            error('Method "%s" exists in "%s" library', name, self.name)
        end

        local meth_instance = tctl_method_new(name, callback, opts)
        self.methods[name] = meth_instance

        return meth_instance:plugin_api()
    end,
    register_prepare = function(self, name, callback)
        log.verbose("registering context prepare function '%s'", name)
        if not is_callable(callback) then
            error('prepare function "%s" is not callable', name)
        end
        table.insert(self.prepare, {name, callback})
    end
}

local tctl_library_methods = {
    plugin_api = function(self)
        return setmetatable(fun.iter(self):tomap(), {
            __index = tctl_library_plugin_methods,
        })
    end,
    public_api = function(self)
        return self
    end,
    return_sorted = function(self)
        local sorted = fun.iter(self.methods):map(function(name, val)
            return {val.help.weight or 0, name}
        end):totable();
        table.sort(sorted, function(l, r) return l[1] < r[1] end)
        return fun.iter(sorted):map(function(value)
            return self.methods[value[2]]
        end):totable()
    end,
    usage = function(self, opts)
        opts = opts or {}
        opts.depth    = opts.depth    or 0
        opts.detailed = opts.detailed or tarantoolctl.help
        local nested = opts.nested
        local depth  = opts.depth

        if tarantoolctl.linkmode then
            local have_linkmode = false
            for name, method in pairs(self.methods) do
                if method.help.linkmode then
                    have_linkmode = true
                    break
                end
            end
            if not have_linkmode then
                if not opts.nested then
                    log.error("%s library doesn't support link mode", self.name)
                end
                return false
            end
        end

        if self.command == nil then
            if nested then
                log.info("%s[%s library]", string.rep(' ', depth), self.name)
            else
                log.error("Expected command name, got nothing")
            end
        elseif self.methods[self.command] == nil then
            log.error("Command '%s' isn't found in module '%s'",
                      self.command, self.name)
        end
        if not nested then
            log.error("")
            usage_header()
        end
        opts.depth = opts.depth + 4
        for _, val in ipairs(self:return_sorted()) do
            val:usage(opts)
            opts.first = true
        end
        opts.depth = opts.depth - 4
        return false
    end,
    run = function(self)
        self.command = table.remove(self.arguments, 1)
        if self.command == nil then
            return self:usage()
        end
        local wrapper = self.methods[self.command]
        if wrapper == nil or tarantoolctl.help then
            return self:usage()
        end
        do -- prepare context here
            self.context.command = self.command
            self.context.positional_arguments = {}
            self.context.keyword_arguments    = {}
            for k, v in pairs(tarantoolctl.arguments) do
                if type(k) == 'number' then
                    self.context.positional_arguments[k] = v
                else
                    self.context.keyword_arguments[k] = v
                end
            end
            for _, prepare in ipairs(self.prepare) do
                local name, cb = unpack(prepare)
                log.verbose("running context prepare function '%s'", name)
                if cb(tarantoolctl:public_api(), self.context) == false then
                    return self:usage()
                end
            end
        end
        return wrapper:run(self.context)
    end,
}

local function tctl_library_new(name, opts)
    local help = opts.help
    opts.help = nil
    return setmetatable({
        name        = name,
        command     = nil,
        methods     = {},
        prepare     = {},
        context     = {},
        arguments   = tarantoolctl.arguments,
        opts        = opts,
        help        = help
    }, {
        __index = tctl_library_methods,
    })
end

local function find_defaults_file_user()
    local user = pwd.getpw()
    log.verbose('user with uid "%d" is used', user.uid)
    if user.id ~= 0 then
        -- check in current directory
        local defaults = fio.pathjoin(fio.cwd(), '.tarantoolctl')
        log.verbose('defaults file: trying to find "%s"', defaults)
        if fio.stat(defaults) then
            return true, defaults
        end
        -- check in home directory
        defaults = user.workdir
        if defaults ~= nil then
            defaults = fio.pathjoin(defaults, '.config/tarantool/tarantool')
            log.verbose('defaults file: trying to find "%s"', defaults)
            if fio.stat(defaults) then
                return true, defaults
            end
        end
    end
    -- we weren't been able to found tarantoolctl config in local/home
    -- directories (or we're 'root')
    return false, nil
end

local function find_defaults_file()
    -- try to find local/user configuration
    local user, defaults = find_defaults_file_user()
    if user == false then
        -- try to find system-wide configuration
        defaults = DEFAULT_DEFAULTS_PATH
        log.verbose('defaults file: trying to find "%s"', defaults)
        if not fio.stat(defaults) then
            defaults = nil
        end
    end

    if defaults == nil then
        log.verbose("can't find defaults file.")
    else
        log.verbose('using "%s" as defaults file', defaults)
    end
    -- no defaults path, assume defaults
    return user, defaults
end

local tctl_plugin_methods = {
    register_library = function(self, name, opts)
        log.verbose("registering library '%s'", name)
        opts = deepcopy(opts or {})
        opts.help = opts.help or {}
        if self.libraries[name] ~= nil then
            log.error("failed to register library. already exists")
            return nil
        end
        if not opts.help.weight then
            opts.help.weight = fun.iter(self.libraries):map(function(_, val)
                return val.help.weight
            end):chain({ 0 }):max() + 10
        end

        local lib_instance = tctl_library_new(name, opts)
        self.libraries[name] = lib_instance

        return lib_instance:plugin_api()
    end,
    register_alias   = function(self, name, dotted_path, cfg)
        log.verbose("registering alias '%s' to '%s'", name, dotted_path)
        local n, path = split_config(dotted_path)
        local lname, mname = unpack(path)
        if n ~= 2 then
            log.error("bad alias path '%s' (expected 2 components, got %d)",
                      dotted_path, n)
            return nil
        end
        local library = self.libraries[lname]
        if library == nil then
            log.error("bad alias path '%s' (library '%s' not found)",
                      dotted_path, lname)
            return nil
        end
        local method = library.methods[mname]
        if method == nil then
            log.error("bad alias path '%s' (method '%s' not found)",
                      dotted_path, lname)
            return nil
        end

        cfg = cfg or {}

        self.aliases[name] = {
            path = dotted_path,
            deprecated = cfg.deprecated or false
        }

        return method:plugin_api()
    end,
    register_config  = function(self, name, opts)
        log.verbose("registering configuration value '%s'", name)
        if opts.deprecated then
            log.verbose("deprecated name: %s", opts.deprecated)
        end
        if opts.type then
            log.verbose("expected type:   %s", opts.type)
        end
        if opts.default then
            log.verbose("default value:   %s", opts.default)
        end
        self.cfg:register(name, opts)
    end
}

local tctl_public_methods = {
    get_config = function(self, name)
        log.verbose("getting configuration value for '%s'", name)
        return self.cfg:get(name)
    end
}

local tctl_methods = {
    load_defaults = function(self)
        self.usermode, self.defaults = find_defaults_file()
        self.cfg:load(self.defaults)
    end,
    load_plugin = function(self, n, file, count)
        local function plugin_count_len(n, count)
            local cnt = #tostring(count)
            return string.format('%0'.. cnt .. 'd/%0' .. cnt .. 'd', n, count)
        end

        file = fio.abspath(file)
        log.verbose("loading plugin %s '%s'", plugin_count_len(n, count), file)
        load_file_sandboxed(file, {}, 'plugins')
    end,
    load_plugin_list = function(self, plugins)
        local plugin_cnt = #plugins
        log.verbose("found %d plugin files", plugin_cnt)
        for n, file in ipairs(plugins) do
            self:load_plugin(n, file, plugin_cnt)
        end
    end,
    load_plugin_directory = function(self, plugin_dir_path)
        log.verbose("loading plugins from '%s'", plugin_dir_path)

        if fio.stat(plugin_dir_path) == nil then
            log.verbose("failed to open path '%s'", plugin_dir_path)
            return nil
        end

        local re_plugins = fio.pathjoin(plugin_dir_path, '*.lua')
        local plugins = fio.glob(re_plugins)

        return self:load_plugin_list(plugins)
    end,
    load_plugin_package_path_patterns = function(self)
        log.verbose("loading plugins from package.path")

        local path_pattern = package.path:gsub('?', '*/tarantoolctl')
        local pattern_list = {}
        for pattern in path_pattern:gmatch('([^;]+);') do
            table.insert(pattern_list, pattern)
        end
        local plugins = {}
        for _, re in ipairs(pattern_list) do
            log.verbose("matching pattern '%s'", re)
            local matched_plugins = fio.glob(re)
            for _, name in ipairs(matched_plugins) do
                log.verbose("found plugin: '%s'", name)
                table.insert(plugins, name)
            end
        end

        return self:load_plugin_list(plugins)
    end,
    plugin_api = function(self)
        return setmetatable(fun.iter(self):tomap(), {
            __index = tctl_plugin_methods,
        })
    end,
    load_plugins = function(self)
        package.loaded['ctl'] = self:plugin_api()
        local plugin_path = os.getenv(ENV_PLUGIN_PATH)
        if plugin_path ~= nil then
            self:load_plugin_directory(plugin_path)
        end
        self:load_plugin_package_path_patterns()
        package.loaded['ctl'] = nil
    end,
    public_api = function(self)
        return setmetatable(fun.iter(self):tomap(), {
            __index = tctl_public_methods,
        })
    end,
    usage = function(self, opts)
        opts = opts or {}
        opts.detailed = opts.detailed or false
        opts.depth    = opts.depth    or 0
        opts.header   = opts.header   or false

        if self.command ~= nil then
            log.error("Unknown library or command name '%s'", self.command)
            log.error("")
        end

        usage_header()

        local sorted = fun.iter(self.libraries):map(function(name, val)
            return {val.help.weight or 0, name}
        end):totable();

        table.sort(sorted, function(l, r) return l[1] < r[1] end)
        opts.depth = opts.depth + 4
        opts.nested = true
        local lsorted = #sorted
        fun.iter(sorted):enumerate():each(function(n, val)
            local rv = self.libraries[val[2]]:usage(opts)
            if rv ~= nil then log.info("") end
        end)
        opts.depth = opts.depth - 4
        return false
    end,
    run = function(self)
        self.command = table.remove(self.arguments, 1)
        if self.command == nil then
            return self:usage()
        end
        log.verbose('running %s', self.command)
        local alias = self.aliases[self.command]
        if alias ~= nil then
            local _, path = split_config(alias.path)
            table.insert(self.arguments, 1, path[2])
            self.command = path[1]
        end
        local wrapper = self.libraries[self.command]
        if wrapper == nil then
            return self:usage()
        end
        return wrapper:run()
    end,
}

tarantoolctl = setmetatable({
    libraries = {},
    aliases   = {},
    plugins   = {},
    cfg = tarantoolctl_cfg_new(),
}, {
    __index = tctl_methods
})
local function is_linkmode(program_name)
    return not (fio.basename(program_name, '.lua') == DEFAULT_WRAPPER_NAME)
end

local function runner(tctl)
    -- make copy of arguments for modification
    tctl.executable   = arg[-1]
    tctl.program_name = arg[ 0]
    tctl.arguments    = argparse(arg)
    tctl.linkmode     = is_linkmode(tctl.program_name)

    local arg = tctl.arguments

    tctl.help         = false
    if arg.h or arg.help then
        tctl.help     = true
    end

    -- we shouldn't throw errors until this place. output before that point is
    -- buggy.
    tctl.verbosity = #(type(arg.v) ~= 'table' and {arg.v} or arg.v)
    if tctl.verbosity > 0 then
        log.level(6)
    end


    tctl:load_defaults()
    tctl:load_plugins()

    local rv = tctl:run()
    if tctl.exiting or rv == false then
        os.exit(rv and 0 or 1)
    end
end

execute_wrapped(runner, tarantoolctl, arg)
-- vim: syntax=lua
